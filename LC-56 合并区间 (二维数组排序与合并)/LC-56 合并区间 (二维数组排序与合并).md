---
Title: LC-56 合并区间 (Merge Intervals)
Type: A
tags:
  - Array
Difficulty: Medium
Time: O(n*logn)
Space: O(n)
Like: 
Solution: 
SourceLink: https://leetcode.cn/problems/search-insert-position
DateStarted: 2023-09-07
DateDone: 2023-09-08
DateModified: 2023-09-08
status: 
aliases: []
---
# LC-56 合并区间 (Merge Intervals)
## 代码实现 (JS)
本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组，关键在于：
1. 排序：将列表中的区间按左端点升序排列
2. 定义一个新的空数组：用于存放合并后的区间  
本方案可满足时间复杂度 `O(nlogn)`，空间复杂度 `O(n)`，用 JavaScript 实现如下：

```js
var merge = function (intervals) {
  // 将列表中的区间按左端点升序排列：.slice() 可不修改原始输入参数
  intervals = intervals.slice().sort((a, b) => a[0] - b[0]);
  // 定义返回的新区间数组，及待加入的区间
  let merged = [];
  let prev = intervals[0];
	// 简化代码，增强循环条件与变量名可读性
  for (const currentInterval of intervals) {
	  // 解构赋值，可更清晰的处理区间起终点;
    const [curStart, curEnd] = currentInterval;
    const [prevStart, prevEnd] = prev;
    // 若当前区间的首位大于待加入区间的末位，则两区间无重合可能
    if (curStart > prevEnd) {
      // 将上个待加入区间推入区间数组，注意不是推入 cur
      merged.push(prev);
      // 更新待加入区间为当前区间
      prev = currentInterval;
    } else {
      // 对比两区间，取末位最大值更新待加入区间
      prev[1] = Math.max(prevEnd, curEnd);
    }
  }
  // 最后一个待加入区间
  merged.push(prev);
  return merged;
};
```

## 实现过程总结
### 一、确定变量
1. 思考给定变量或已知变量:
	- 未排序的区间数组 `intervals`
2. 定义其他需要的输入、输出变量:
	- $ 按照左端点升序排序后的区间数组 `intervals.sort((a, b) => a[0] - b[0])`
	- $ 待返回的新区间数组 `merged`
	- 待加入的区间 `prev`
	- 当前对比区间 `cur` 或 `currentInterval` 
### 二、确定循环条件
1. 依次比较区间数组中的每个区间：
	- 一版：`for (i = 0; i < intervals.length; i++)`
	- 二版：`for (const currentInterval of Intervals)`
2. 判断当前区间的首位是否大于待加入区间的末位
	- 若是，则两区间无重合可能
		- $ 将上个待加入区间推入区间数组，注意不是推入 cur：`merged.push(prev)`
		- 更新待加入区间为当前区间
	- 若否，对比两区间末位
		- $ 取末位最大值更新待加入区间 `prev[1] = Math.max(prev[1], cur[1]);`
### 三、测试、绘图可视化
> 这一步可用 DrawIO 绘图：
- ![[LC-G-56.svg|475]]
### 四、代码优化总结
1. 不修改原始输入参数的排序：**`intervals.slice().sort((a, b) => a[0] - b[0])`**
2. 简化代码，增强循环条件与变量名可读性：**`for (... of ...){}`**
3. 解构赋值，可更清晰的处理区间起终点;
4. 循环结构中的常量声明能用 const 而不是 let 符合最佳实践与代码规范，可防止意外修改 